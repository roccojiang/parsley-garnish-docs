\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Related Work}
Library-specific linters are rare because they require a non-trivial amount of work to implement.
Even more niche is linters for embedded DSLs.
This thesis can also be seen as a rough framework for implementing a linter for an eDSL (esp. Parser datatype to represent DSL model).
afaik nothing this complex has been done in scalafix

Related to scalafix, so it could be possible to do very similar things as I've done:
Rust (I can see this as possible, ask Boogle people for thoughts?) -- Clippy lint passes % https://doc.rust-lang.org/clippy/development/lint_passes.html
C\# -- Roslyn

Library-specific linters:
xunit.analyzers -- seems to be relatively simple one-off rules though, not a DSL

Things that could help:
Squid quasiquotes: type-safe and hygienic quasiquotes -- but only for scala 2.11/12
* squid quasiquotes have rudimentary function inlining features https://infoscience.epfl.ch/record/231700
Scala 3 macros: I wonder if this could help?

Related concepts to the Function stuff:
Metaprogramming and multi-staged programming? a dual: instead of for optimisation/code-generation purposes, we do it just for stringifying
Actually I feel like I've borrowed a lot of stuff from metaprogramming optimisation techniques -- Haskell Parsley itself

\ourchapter{Conclusion}
\section{Review}
\section{Future Work}

\end{document}
