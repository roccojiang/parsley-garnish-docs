@article{hudak_building_1996,
  author     = {Hudak, Paul},
  title      = {Building domain-specific embedded languages},
  year       = {1996},
  issue_date = {Dec. 1996},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {4es},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/242224.242477},
  doi        = {10.1145/242224.242477},
  journal    = {ACM Comput. Surv.},
  month      = dec,
  pages      = {196--es}
}

@article{baqais-lit-review-2019,
  title     = {Automatic software refactoring: a systematic literature review},
  volume    = {28},
  issn      = {1573-1367},
  url       = {http://dx.doi.org/10.1007/s11219-019-09477-y},
  doi       = {10.1007/s11219-019-09477-y},
  number    = {2},
  journal   = {Software Quality Journal},
  publisher = {Springer Science and Business Media LLC},
  author    = {Baqais,  Abdulrahman Ahmed Bobakr and Alshayeb,  Mohammad},
  year      = {2019},
  month     = dec,
  pages     = {459-502}
}

@inproceedings{kurbatova_intellij_2021,
  author    = {Kurbatova, Zarina and Golubev, Yaroslav and Kovalenko, Vladimir and Bryksin, Timofey},
  booktitle = {2021 36th IEEE/ACM International Conference on Automated Software Engineering Workshops (ASEW)},
  title     = {The IntelliJ Platform: A Framework for Building Plugins and Mining Software Data},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {14-17},
  url       = {https://doi.org/10.1109/asew52652.2021.00016},
  doi       = {10.1109/asew52652.2021.00016}
}

@inproceedings{renggli_domain-specific_2010,
  address   = {Berlin, Heidelberg},
  series    = {Lecture {Notes} in {Computer} {Science}},
  title     = {Domain-{Specific} {Program} {Checking}},
  isbn      = {978-3-642-13953-6},
  doi       = {10.1007/978-3-642-13953-6_12},
  url       = {https://doi.org/10.1007/978-3-642-13953-6_12},
  language  = {en},
  booktitle = {TOOLS'10: Proceedings of the 48th International Conference on Objects, {Models}, {Components}, {Patterns}},
  volume    = {6141},
  publisher = {Springer},
  author    = {Renggli, Lukas and Ducasse, Stéphane and Gîrba, Tudor and Nierstrasz, Oscar},
  editor    = {Vitek, Jan},
  year      = {2010},
  pages     = {213--232}
}

@article{gregor_stllint_2006,
  author  = {Gregor, Douglas and Schupp, Sibylle},
  title   = {STLlint: lifting static checking from languages to libraries},
  journal = {Software: Practice and Experience},
  volume  = {36},
  number  = {3},
  pages   = {225-254},
  doi     = {10.1002/spe.683},
  url     = {https://doi.org/10.1002/spe.683},
  year    = {2006}
}

@inproceedings{blanchet_static-analyzer_2003,
  author    = {Blanchet, Bruno and Cousot, Patrick and Cousot, Radhia and Feret, J\'{e}rome and Mauborgne, Laurent and Min\'{e}, Antoine and Monniaux, David and Rival, Xavier},
  title     = {A static analyzer for large safety-critical software},
  year      = {2003},
  month     = jun,
  isbn      = {1581136625},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/781131.781153},
  doi       = {10.1145/781131.781153},
  abstract  = {We show that abstract interpretation-based static program analysis can be made efficient and precise enough to formally verify a class of properties for a family of large programs with few or no false alarms. This is achieved by refinement of a general purpose static analyzer and later adaptation to particular programs of the family by the end-user through parametrization. This is applied to the proof of soundness of data manipulation operations at the machine level for periodic synchronous safety critical embedded software.The main novelties are the design principle of static analyzers by refinement and adaptation through parametrization (Sect. 3 and 7), the symbolic manipulation of expressions to improve the precision of abstract transfer functions (Sect. 6.3), the octagon (Sect. 6.2.2), ellipsoid (Sect. 6.2.3), and decision tree (Sect. 6.2.4) abstract domains, all with sound handling of rounding errors in oating point computations, widening strategies (with thresholds: Sect. 7.1.2, delayed: Sect. 7.1.3) and the automatic determination of the parameters (parametrized packing: Sect. 7.2).},
  booktitle = {Proceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation},
  pages     = {196--207},
  numpages  = {12},
  keywords  = {abstract domains, abstract interpretation, embedded, floating point, reactive, real-time, safety-critical software, static analysis, verification},
  location  = {San Diego, California, USA},
  series    = {PLDI '03}
}

@article{hovemeyer_finding-bugs_2004,
  author    = {Hovemeyer, David and Pugh, William},
  title     = {Finding bugs is easy},
  year      = {2004},
  month     = dec,
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  volume    = {39},
  number    = {12},
  issn      = {0362-1340},
  url       = {https://doi.org/10.1145/1052883.1052895},
  doi       = {10.1145/1052883.1052895},
  abstract  = {Many techniques have been developed over the years to automatically find bugs in software. Often, these techniques rely on formal methods and sophisticated program analysis. While these techniques are valuable, they can be difficult to apply, and they aren't always effective in finding real bugs.Bug patterns are code idioms that are often errors. We have implemented automatic detectors for a variety of bug patterns found in Java programs. In this paper, we describe how we have used bug pattern detectors to find serious bugs in several widely used Java applications and libraries. We have found that the effort required to implement a bug pattern detector tends to be low, and that even extremely simple detectors find bugs in real applications.From our experience applying bug pattern detectors to real programs, we have drawn several interesting conclusions. First, we have found that even well tested code written by experts contains a surprising number of obvious bugs. Second, Java (and similar languages) have many language features and APIs which are prone to misuse. Finally, that simple automatic techniques can be effective at countering the impact of both ordinary mistakes and misunderstood language features.},
  journal   = {SIGPLAN Not.},
  pages     = {92--106},
  numpages  = {15}
}

@book{johnson_lint_1978,
  title     = {Lint, a C program checker},
  author    = {Johnson, Stephen C},
  year      = {1978},
  publisher = {AT\&T Bell Laboratories},
  note      = {Technical Report 65}
}

@article{sadowski_analysis-google_2018,
  author     = {Sadowski, Caitlin and Aftandilian, Edward and Eagle, Alex and Miller-Cushon, Liam and Jaspan, Ciera},
  title      = {Lessons from building static analysis tools at Google},
  year       = {2018},
  issue_date = {April 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {61},
  number     = {4},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/3188720},
  doi        = {10.1145/3188720},
  abstract   = {For a static analysis project to succeed, developers must feel they benefit from and enjoy using it.},
  journal    = {Commun. ACM},
  month      = mar,
  pages      = {58--66},
  numpages   = {9}
}

@inproceedings{calcagno_moving-facebook_2015,
  author    = {Calcagno, Cristiano
               and Distefano, Dino
               and Dubreil, Jeremy
               and Gabi, Dominik
               and Hooimeijer, Pieter
               and Luca, Martino
               and O'Hearn, Peter
               and Papakonstantinou, Irene
               and Purbrick, Jim
               and Rodriguez, Dulma},
  editor    = {Havelund, Klaus
               and Holzmann, Gerard
               and Joshi, Rajeev},
  title     = {Moving Fast with Software Verification},
  booktitle = {NASA Formal Methods},
  year      = {2015},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {3--11},
  abstract  = {For organisations like Facebook, high quality software is important. However, the pace of change and increasing complexity of modern code makes it difficult to produce error-free software. Available tools are often lacking in helping programmers develop more reliable and secure applications.},
  isbn      = {978-3-319-17524-9},
  doi       = {10.1007/978-3-319-17524-9_1},
  url       = {https://doi.org/10.1007/978-3-319-17524-9_1}
}

@book{fowler_refactoring_2018,
  title     = {Refactoring: Improving the Design of Existing Code},
  publisher = {Addison-Wesley},
  author    = {Fowler, Martin},
  year      = {2018},
  isbn      = {9780134757681}
}

@book{gunasinghe_lsp_2022,
  address    = {Berkeley, CA},
  title      = {Language {Server} {Protocol} and {Implementation}: {Supporting} {Language}-{Smart} {Editing} and {Programming} {Tools}},
  isbn       = {978-1-4842-7791-1},
  shorttitle = {Language {Server} {Protocol} and {Implementation}},
  language   = {en},
  urldate    = {2024-01-25},
  publisher  = {Apress},
  author     = {Gunasinghe, Nadeeshaan and Marcus, Nipuna},
  year       = {2022},
  doi        = {10.1007/978-1-4842-7792-8},
  url        = {https://doi.org/10.1007/978-1-4842-7792-8}
}

@techreport{van_rossum_pep8_2001,
  author = {van Rossum, Guido and Warsaw, Barry and Coghlan, Nick},
  title  = {Style Guide for {Python} Code},
  year   = {2001},
  month  = {jul},
  type   = {PEP},
  number = {8},
  url    = {https://peps.python.org/pep-0008/}
}

@misc{li_clippy_2023,
  title     = {Unleashing the {Power} of {Clippy} in {Real}-{World} {Rust} {Projects}},
  url       = {https://doi.org/10.48550/arXiv.2310.11738},
  doi       = {10.48550/arXiv.2310.11738},
  urldate   = {2024-01-25},
  publisher = {arXiv},
  author    = {Li, Chunmiao and Yu, Yijun and Wu, Haitao and Carlig, Luca and Nie, Shijie and Jiang, Lingxiao},
  month     = oct,
  year      = {2023}
}

@inproceedings{hora_domain_2012,
  author    = {Hora, André and Anquetil, Nicolas and Ducasse, Stéphane and Allier, Simon},
  booktitle = {2012 28th IEEE International Conference on Software Maintenance (ICSM)},
  title     = {Domain specific warnings: Are they any better?},
  year      = {2012},
  pages     = {441-450},
  doi       = {10.1109/ICSM.2012.6405305},
  url       = {https://doi.org/10.1109/ICSM.2012.6405305}
}

@inproceedings{pickering_plugins_2019,
  author    = {Pickering, Matthew and Wu, Nicolas and N\'{e}meth, Boldizs\'{a}r},
  title     = {Working with source plugins},
  year      = {2019},
  isbn      = {9781450368131},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3331545.3342599},
  doi       = {10.1145/3331545.3342599},
  booktitle = {Proceedings of the 12th ACM SIGPLAN International Symposium on Haskell},
  pages     = {85--97},
  numpages  = {13},
  location  = {Berlin, Germany},
  series    = {Haskell 2019}
}

@misc{lampepfl_changes_2022,
  title   = {Changes in {Compiler} {Plugins}},
  url     = {https://docs.scala-lang.org/scala3/reference/changed-features/compiler-plugins.html},
  urldate = {2024-01-25},
  journal = {Scala 3 Reference},
  author  = {LAMP/EPFL},
  month   = nov,
  year    = {2022}
}

@inproceedings{sherwany_refactoring_2015,
  author    = {Sherwany, Amanj
               and Zaza, Nosheen
               and Nystrom, Nathaniel},
  editor    = {Franke, Bj\'{o}rn},
  title     = {A Refactoring Library for Scala Compiler Extensions},
  booktitle = {Compiler Construction},
  year      = {2015},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {31--48},
  isbn      = {978-3-662-46663-6},
  doi       = {10.1007/978-3-662-46663-6_2},
  url       = {https://doi.org/10.1007/978-3-662-46663-6_2}
}

@phdthesis{burmako_scalameta_2017,
  address = {Lausanne},
  title   = {Unification of {Compile}-{Time} and {Runtime} {Metaprogramming} in {Scala}},
  school  = {EPFL},
  author  = {Burmako, Eugene},
  year    = {2017},
  month   = mar,
  type    = {Ph.D. Thesis},
  doi     = {10.5075/epfl-thesis-7159},
  url     = {https://doi.org/10.5075/epfl-thesis-7159}
}

@misc{geirsson_catch_2017,
  title   = {Catch bugs with {Scalafix} v0.5},
  url     = {https://www.scala-lang.org/blog/2017/09/11/scalafix-v0.5.html},
  urldate = {2024-01-25},
  journal = {The Scala Programming Language},
  author  = {Geirsson, {\'O}lafur},
  month   = nov,
  year    = {2017}
}

@misc{geirsson_scalafix_2016,
  title   = {Introducing {Scalafix}: a code migration tool for {Scala}},
  url     = {https://scala-lang.org/blog/2016/10/24/scalafix.html},
  urldate = {2024-01-25},
  journal = {The Scala Programming Language},
  author  = {Geirsson, {\'O}lafur},
  month   = oct,
  year    = {2016}
}

@inproceedings{gong_dlint_2015,
  author    = {Gong, Liang and Pradel, Michael and Sridharan, Manu and Sen, Koushik},
  title     = {DLint: dynamically checking bad coding practices in JavaScript},
  month     = jul,
  year      = {2015},
  isbn      = {9781450336208},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2771783.2771809},
  doi       = {10.1145/2771783.2771809},
  booktitle = {Proceedings of the 2015 International Symposium on Software Testing and Analysis},
  pages     = {94--105},
  numpages  = {12},
  location  = {Baltimore, MD, USA},
  series    = {ISSTA 2015}
}

@misc{scalacenter_scalafix_2024,
  title    = {Scalafix: Developer Guide},
  url      = {https://scalacenter.github.io/scalafix/docs/developers/tutorial.html},
  language = {en},
  urldate  = {2024-03-25},
  author   = {{Scala Center}},
  month    = feb,
  year     = {2024}
}

@misc{scalameta_semanticdb_guide_2023,
  title    = {Scalameta: {SemanticDB} Guide},
  url      = {https://scalameta.org/docs/semanticdb/guide.html},
  language = {en},
  urldate  = {2024-03-25},
  author   = {{Scalameta}},
  month    = jul,
  year     = {2023}
}

@misc{scalameta_semanticdb_spec_2023,
  title    = {Scalameta: {SemanticDB} Specification},
  url      = {https://scalameta.org/docs/semanticdb/specification.html},
  language = {en},
  urldate  = {2024-03-25},
  author   = {{Scalameta}},
  month    = nov,
  year     = {2023}
}

@misc{jaglin_scalafix_2024,
  address  = {Nantes, France},
  title    = {Unleashing {Scalafix} potential with custom rules},
  url      = {https://scala.io/talks/unleashing-scalafix-potential},
  language = {en},
  urldate  = {2024-03-25},
  author   = {Jaglin, Brice},
  month    = feb,
  year     = {2024}
}

@techreport{shabalin_quasiquotes_2013,
  title       = {Quasiquotes for Scala},
  author      = {Shabalin, Denys and Burmako, Eugene and Odersky, Martin},
  institution = {EPFL},
  pages       = {15},
  month       = mar,
  year        = {2013},
  url         = {http://infoscience.epfl.ch/record/185242}
}

@inproceedings{willis_garnishing_2018,
  address   = {New York, NY, USA},
  series    = {Scala 2018},
  title     = {Garnishing parsec with parsley},
  isbn      = {978-1-4503-5836-1},
  url       = {https://doi.org/10.1145/3241653.3241656},
  doi       = {10.1145/3241653.3241656},
  abstract  = {Parser combinators are a clean and powerful abstraction which can provide reasonably efficient means of parsing a grammar into a form which the programmer desires. They remain close to the domain of grammars whilst at the same time offering enormous flexibility. In Haskell, the Parsec library is a prime example of such a library. However, a direct translation to Scala proves to be unbearably slow. This paper describes the semantics and design of a new library, called Parsley, which retains a close resemblance to Parsec style whilst providing very competitive performance.},
  booktitle = {Proceedings of the 9th {ACM} {SIGPLAN} {International} {Symposium} on {Scala}},
  publisher = {Association for Computing Machinery},
  author    = {Willis, Jamie and Wu, Nicolas},
  month     = sep,
  year      = {2018},
  keywords  = {Combinators, Domain-Specific Languages, Parsers},
  pages     = {24--34}
}

@techreport{leijen_parsec_2001,
  author   = {Leijen, Daan and Meijer, Erik},
  title    = {Parsec: Direct Style Monadic Parser Combinators for the Real World},
  year     = {2001},
  month    = jul,
  abstract = {Despite the long list of publications on parser combinators, there does not yet exist a monadic parser combinator library that is applicable in real world situations. In particular naive implementations of parser combinators are likely to suffer from space leaks and are often unable to report precise error messages in case of parse errors. The Parsec parser combinator library described in this paper, utilizes a novel implementation technique for space and time efficient parser combinators that in case of a parse error, report both the position of the error as well as all grammar productions that would have been legal at that point in the input.},
  url      = {https://www.microsoft.com/en-us/research/publication/parsec-direct-style-monadic-parser-combinators-for-the-real-world/},
  edition  = {Technical Report UU-CS-2001-35, Departement of Computer Science, Universiteit Utrecht},
  number   = {UU-CS-2001-27},
  note     = {User Modeling 2007, 11th International Conference, UM 2007, Corfu, Greece, June 25-29, 2007}
}

 @article{hutton_higher-order_1992,
  title     = {Higher-order functions for parsing},
  volume    = {2},
  issn      = {1469-7653},
  url       = {https://doi.org/10.1017/S0956796800000411},
  doi       = {10.1017/s0956796800000411},
  number    = {3},
  journal   = {Journal of Functional Programming},
  publisher = {Cambridge University Press},
  author    = {Hutton, Graham},
  year      = {1992},
  month     = jul,
  pages     = {323--343}
}

@inproceedings{willis_design_2022,
  author    = {Willis, Jamie and Wu, Nicolas},
  title     = {Design patterns for parser combinators in Scala},
  year      = {2022},
  isbn      = {9781450394635},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3550198.3550427},
  doi       = {10.1145/3550198.3550427},
  booktitle = {Proceedings of the Scala Symposium},
  pages     = {9--21},
  numpages  = {13},
  location  = {Berlin, Germany},
  series    = {Scala '22}
}

@book{parr_antlr_2013,
  author    = {Parr, Terence},
  title     = {The Definitive ANTLR 4 Reference},
  year      = {2013},
  month     = jan,
  isbn      = {1934356999},
  publisher = {Pragmatic Bookshelf},
  edition   = {2nd}
}

@phdthesis{willis_parsley_2023,
  address = {London},
  type    = {Ph.D. Thesis},
  title   = {Parsley: {Optimising} and {Improving} {Parser} {Combinators}},
  url     = {https://doi.org/10.25560/110313},
  doi     = {10.25560/110313},
  school  = {Imperial College London},
  author  = {Willis, Jamie},
  month   = aug,
  year    = {2023}
}

@article{willis_staged_2023,
  author     = {Willis, Jamie and Wu, Nicolas and Pickering, Matthew},
  title      = {Staged selective parser combinators},
  year       = {2020},
  issue_date = {August 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3409002},
  doi        = {10.1145/3409002},
  journal    = {Proc. ACM Program. Lang.},
  month      = aug,
  articleno  = {120},
  numpages   = {30}
}

@inproceedings{mitchell_uniform_2007,
  author    = {Mitchell, Neil and Runciman, Colin},
  title     = {Uniform boilerplate and list processing},
  year      = {2007},
  isbn      = {9781595936745},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1291201.1291208},
  doi       = {10.1145/1291201.1291208},
  booktitle = {Proceedings of the ACM SIGPLAN Workshop on Haskell Workshop},
  pages     = {49--60},
  numpages  = {12},
  location  = {Freiburg, Germany},
  series    = {Haskell '07}
}

@inproceedings{gibbons_dsls_2014,
  author    = {Gibbons, Jeremy and Wu, Nicolas},
  title     = {Folding domain-specific languages: deep and shallow embeddings (functional pearl)},
  year      = {2014},
  isbn      = {9781450328739},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2628136.2628138},
  doi       = {10.1145/2628136.2628138},
  abstract  = {A domain-specific language can be implemented by embedding within a general-purpose host language. This embedding may be deep or shallow, depending on whether terms in the language construct syntactic or semantic representations. The deep and shallow styles are closely related, and intimately connected to folds; in this paper, we explore that connection.},
  booktitle = {Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming},
  pages     = {339--347},
  numpages  = {9},
  keywords  = {folds, domain-specific languages, deep and shallow embedding},
  location  = {Gothenburg, Sweden},
  series    = {ICFP '14}
}

@inproceedings{reynolds_defunc_1972,
  author    = {Reynolds, John C.},
  title     = {Definitional interpreters for higher-order programming languages},
  year      = {1972},
  isbn      = {9781450374927},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/800194.805852},
  doi       = {10.1145/800194.805852},
  abstract  = {Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.},
  booktitle = {Proceedings of the ACM Annual Conference - Volume 2},
  pages     = {717--740},
  numpages  = {24},
  keywords  = {Applicative language, Closure, Continuation, GEDANKEN, Higher-order function, Interpreter, J-operator, LISP, Lambda calculus, Language definition, Order of application, PAL, Programming language, Reference, SECD machine},
  location  = {Boston, Massachusetts, USA},
  series    = {ACM '72}
}

@inproceedings{danvy_defunctionalization_2001,
  author    = {Danvy, Olivier and Nielsen, Lasse R.},
  title     = {Defunctionalization at work},
  year      = {2001},
  isbn      = {158113388X},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/773184.773202},
  doi       = {10.1145/773184.773202},
  abstract  = {Reynolds's defunctionalization technique is a whole-program transformation from higher-order to first-order functional programs. We study practical applications of this transformation and uncover new connections between seemingly unrelated higher-order and first-order specifications and between their correctness proofs. Defunctionalization therefore appearsboth as a springboard for rev ealing new connections and as a bridge for transferring existing results between the first-order world and the higher-order world.},
  booktitle = {Proceedings of the 3rd ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
  pages     = {162--174},
  numpages  = {13},
  keywords  = {CPS transformation, ML, Scheme, church encoding, closure conversion, continuation-passing style (CPS), continuations, defunctionalization, direct-style transformation, first-order programs, higher-order programs, lambda-lifting, regular expressions, supercombinator conversion, syntactic theories},
  location  = {Florence, Italy},
  series    = {PPDP '01}
}

@techreport{cheney_gadt_2003,
  title       = {First-class phantom types},
  author      = {Cheney, James and Hinze, Ralf},
  year        = {2003},
  month       = jul,
  url         = {https://hdl.handle.net/1813/5614},
  institution = {Cornell University}
}

@article{church_lambda_1936,
  issn      = {00029327, 10806377},
  doi       = {10.2307/2371045},
  url       = {https://doi.org/10.2307/2371045},
  author    = {Church, Alonzo},
  journal   = {American Journal of Mathematics},
  number    = {2},
  pages     = {345--363},
  publisher = {Johns Hopkins University Press},
  title     = {An Unsolvable Problem of Elementary Number Theory},
  urldate   = {2024-06-06},
  volume    = {58},
  year      = {1936}
}

@inproceedings{parreaux_towards_2019,
  author    = {Parreaux, Lionel and Boruch-Gruszecki, Aleksander and Giarrusso, Paolo G.},
  title     = {Towards improved GADT reasoning in Scala},
  year      = {2019},
  isbn      = {9781450368247},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3337932.3338813},
  doi       = {10.1145/3337932.3338813},
  abstract  = {Generalized algebraic data types (GADT) have been notoriously difficult to implement correctly in Scala. Both major Scala compilers, Scalac and Dotty, are currently known to have type soundness holes related to them. In particular, covariant GADTs have exposed paradoxes due to Scala's inheritance model. We informally explore foundations for GADTs within Scala's core type system, to guide a principled understanding and implementation of GADTs in Scala.},
  booktitle = {Proceedings of the Tenth ACM SIGPLAN Symposium on Scala},
  pages     = {12--16},
  numpages  = {5},
  keywords  = {generalized algebraic data types, Scala, DOT},
  location  = {London, United Kingdom},
  series    = {Scala '19}
}

@inproceedings{wang_strong_2017,
  author    = {Wang, Fei and Rompf, Tiark},
  title     = {{Towards Strong Normalization for Dependent Object Types (DOT)}},
  booktitle = {31st European Conference on Object-Oriented Programming (ECOOP 2017)},
  pages     = {27:1--27:25},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  isbn      = {978-3-95977-035-4},
  issn      = {1868-8969},
  year      = {2017},
  volume    = {74},
  editor    = {M\"{u}ller, Peter},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address   = {Dagstuhl, Germany},
  url       = {https://doi.org/10.4230/LIPIcs.ECOOP.2017.27},
  urn       = {urn:nbn:de:0030-drops-72763},
  doi       = {10.4230/LIPIcs.ECOOP.2017.27},
  annote    = {Keywords: Scala, DOT, strong normalization, logical relations, recursive types}
}
