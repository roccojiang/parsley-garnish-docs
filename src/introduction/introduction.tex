\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Introduction}

% TODO: JW feedback -- Example of problem, outline how hard that is to solve for users etc. Then contributions + outline

Parser combinators~\cite{hutton_higher-order_1992} are an elegant approach for writing parsers in a manner that remains close to their original grammar specification.
\texttt{parsley}~\cite{willis_garnishing_2018} is a parser combinator library implemented as an embedded domain-specific language (\textsc{dsl})~\cite{hudak_building_1996} in Scala, with an \textsc{api} inspired by the \texttt{parsec}~\cite{leijen_parsec_2001} family of libraries in Haskell.
However, as with many libraries, there exists a learning curve to utilising \texttt{parsley} and parser combinator libraries in an idiomatic manner.

While well-documented, the wealth of information to get started with \texttt{parsley} can be overwhelming for users, particularly those new to parser combinators.
Although \texttt{parsley} itself has a user-friendly \textsc{api}, parser combinators in general have pitfalls that may be unexpected for new users.
Even experienced users can unintentionally write unidiomatic parsers: \texttt{parsley} has first-class support for a number of design patterns~\cite{willis_design_2022} for writing maintainable parsers, which users migrating from other parser combinator libraries may not be aware of.

This project aims to address these issues by developing a companion \emph{linting} tool for \texttt{parsley}, called \texttt{parsley-garnish}, that provides automated code hints and fixes to assist users in writing idiomatic and correct parsers.
A number of modern integrated development environments (\textsc{ide}s) provide code hints to warn programmers about problems in their source code, highlighting offending snippets and suggesting actions to improve suboptimal or incorrect code~\cite{kurbatova_intellij_2021}.
Many of these linters are designed to detect general issues for the host language, rather than specifically for libraries.
However, tools may also utilise domain-specific code analyses in order to detect issues specific to a particular system or problem domain~\cite{renggli_domain-specific_2010,gregor_stllint_2006}.
Well-designed linters can offer significant benefits to users:
\begin{itemize}
  \item Linters can be particularly valuable for uncovering subtle issues that might be hard to diagnose and locate, especially in large codebases. Automated fixes can save further effort by resolving issues without manual intervention.
  \item Linters are also beneficial for teaching best practices in context, offering relevant hints and improvements precisely where sub-optimal code is detected.
\end{itemize}
%
For example, suppose a user wants to write a simple arithmetic expression parser in \texttt{parsley}, which evaluates the parsed expression as a floating-point calculation.
The parser will be based on the following e\textsc{bnf} grammar, with standard arithmetic operator precedence and left-associativity:
\begin{align*}
\langle \mathit{digit} \rangle &::= \text{`\texttt{0}'} \ldots \text{`\texttt{9}'} \\
\langle \mathit{number} \rangle &::= \langle \mathit{digit} \rangle+ \\
\langle \mathit{expr} \rangle &::= \langle \mathit{expr} \rangle \; \text{`\texttt{+}'} \; \langle \mathit{term} \rangle \enspace | \enspace
                                \langle \mathit{expr} \rangle \; \text{`\texttt{-}'} \; \langle \mathit{term} \rangle \enspace | \enspace
                                \langle \mathit{term} \rangle \\
\langle \mathit{term} \rangle &::= \langle \mathit{term} \rangle \; \text{`\texttt{*}'} \; \langle \mathit{atom} \rangle \enspace | \enspace
                                \langle \mathit{term} \rangle \; \text{`\texttt{/}'} \; \langle \mathit{atom} \rangle \enspace | \enspace
                                \langle \mathit{atom} \rangle \\
\langle \mathit{atom} \rangle &::= \text{`\texttt{(}'} \; \langle \mathit{expr} \rangle \; \text{`\texttt{)}'} \enspace | \enspace
                                \langle \mathit{number} \rangle
\end{align*}
%
By closely following the structure of the grammar, a naïve first attempt at writing the parser-evaluator in \texttt{parsley} may resemble the following:
% import parsley.Parsley
% import parsley.character.{char, digit}
% import parsley.syntax.zipped._
\begin{minted}{scala}
val number: Parsley[Float] = digit.foldLeft1(0)((n, d) => n * 10 + d.asDigit).map(_.toFloat)

lazy val expr: Parsley[Float] = (expr, char('+') ~> term).zipped(_ + _)
                              | (expr, char('-') ~> term).zipped(_ - _)
                              | term
lazy val term: Parsley[Float] = (term, char('*') ~> atom).zipped(_ * _)
                              | (term, char('/') ~> atom).zipped(_ / _)
                              | atom
lazy val atom: Parsley[Float] = char('(') ~> expr <~ char(')') | number
\end{minted}
%
Although this parser compiles and looks correct at first glance, it suffers from a puzzling runtime behaviour.
Attempting to run the parser by executing \scala{expr.parse("1+2*3/4")} results in a cryptic \scala{StackOverflowError} when compiled in Scala 2.
Running the same code on Scala 3 shines some light on the issue: the compiler reports an ``infinite loop in function body'' for \scala{expr} and \scala{term}.
The user has stumbled upon the age-old problem of \emph{left-recursion}, which the grammar uses to encode the left-associative behaviour of the arithmetic operators.
Left-recursive grammars are problematic for recursive-descent parsers, which are the class of parsers that \texttt{parsley} produces.
A recursive-descent parser would see that the first thing to parse when attempting to parse \scala{expr} is \scala{expr} itself, leading to an infinite cycle.

The caveat of left-recursion may not be immediately obvious to a novice user, and even less obvious is how to resolve the issue in an idiomatic manner.
This situation is exactly where a domain-specific linter like \texttt{parsley-garnish} can be invaluable.
A linter with knowledge of the \texttt{parsley} library could help users by providing \emph{relevant} suggestions at the \emph{precise} location of the issue:
\begin{minted}{scala}
lazy val expr: Parsley[Float] = (expr, char('+') ~> term).zipped(_ + _)
//       ^^^^^^^^^^^^^^^^^^^^
// Warning: This parser is left-recursive, which will cause an infinite loop when parsing.
// Suggestion: Refactor using chain combinators from the parsley.expr module,
//             or with a precedence table from the parsley.expr.precedence module.
\end{minted}
%
In addition to the correctness issue, the left-recursive parser example also suffers from a stylistic problem:
overuse of the \scala{char} combinator leads to visual clutter, making the parser harder to read.
In \texttt{parsley}, this can be addressed by using implicit conversions to lift character literals directly to parsers -- this feature may not be known to users new to the library.
Thus, a linter could also aid users in learning about \texttt{parsley} idioms and best practices:
\begin{minted}{scala}
lazy val atom: Parsley[Float] = char('(') ~> expr <~ char(')') | number
//                              ^^^^^^^^^            ^^^^^^^^^
// Info: Explicit usage of the 'char' combinator may not be necessary.
// Suggestion [auto-fix available]: Use implicit conversions:
// import parsley.syntax.character.charLift
// ─────┬──────────────────────────────────
//      └── Bring implicit conversion into scope
//
// lazy val atom: Parsley[Float] = '(' ~> expr <~ ')' | number
//                                 ─┬─            ─┬─
//      Remove char combinators ────┴──────────────┘
\end{minted}
%
The aim of \texttt{parsley-garnish} is to provide relevant linting rules, like the above, to guide users towards writing improved \texttt{parsley} code.
With useful hints and possibly automatic fixes, our hypothetical user can be steered towards a correct and idiomatic parser:
% import parsley.Parsley
% import parsley.syntax.character.charLift
% import parsley.expr.{precedence, Ops, InfixL}
\begin{minted}{scala}
lazy val expr: Parsley[Float] = precedence('(' ~> expr <~ ')', number)(
  Ops(InfixL)('*' as (_ * _), '/' as (_ / _)),
  Ops(InfixL)('+' as (_ + _), '-' as (_ - _))
)
\end{minted}
%
With this definition of \scala{expr}, the parser is able to parse left-associative expressions without left-recursion, and the syntactic noise of the \scala{char} combinators has been removed.
Executing \scala{expr.parse("1+2*3/4")} now correctly evaluates to \scala{2.5}!

% \section{Project Goals}
% This project aims to explore the potential of harnessing static code analysis techniques to develop a new tool, \texttt{parsley-garnish}, that offers code hints aimed at assisting programmers in writing idiomatic and correct \texttt{parsley} code.
% Additionally, for certain issues that can be automatically fixed, \texttt{parsley-garnish} will provide automated actions to resolve the issue. % TODO: via code transformations - put this in the background?
% The goal of \texttt{parsley-garnish} is to be used as a companion library to \texttt{parsley}, in order to improve its ease of adoption and to help users enforce best practices.

% TODO: mention wacc students

% Introduces domain-specific lint rules for Parsec-style parser combinator libraries
% Implementation of these rules for Parsley Scala
% Developing the required machinery on top of raw AST manipulation, to perform code rewrites for them
% Producing simplified parser/expression terms is equivalent to Parsley Haskell’s high-level optimisations
% This holds for any algebra-based DSL where code transformations perform algebraic operations → requires simplification based on algebraic laws
% E.g. Finally, a Polymorphic Linear Algebra Language (Pearl)
% If you implement simplifications for a code-rewriting linter, you unlock staged optimisations ⇔ if you implement staged optimisations, you unlock easily writing auto-fix lints

\section*{Contributions}
The contributions of this project are summarised as follows:
\begin{itemize}
  \item poo
\end{itemize}

\section*{Outline}

\end{document}
