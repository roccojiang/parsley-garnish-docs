\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Introduction}

\section{Motivation}
Parser combinators~\cite{hutton_higher-order_1992} are an elegant approach for writing parsers in a manner that remains close to the original grammar specification.
\texttt{parsley}~\cite{willis_garnishing_2018} is a parser combinator library implemented as an embedded domain-specific language (\textsc{dsl})~\cite{hudak_building_1996} in Scala, with an API inspired by the \texttt{parsec}~\cite{leijen_parsec_2001} family of libraries in Haskell.
However, as with many libraries, there exists a learning curve to utilising \texttt{parsley} and parser combinator libraries in an idiomatic manner.

While well-documented, the wealth of information to get started with \texttt{parsley} can be overwhelming for users, particularly those new to parser combinators.
Furthermore, there exists a number of design patterns~\cite{willis_design_2022} for writing maintainable parsers, which even experienced users may be unaware of.
A potential solution to this problem is tooling to provide automated code hints, which a user can use during the development cycle to evaluate if their code adheres to best practices.

% TODO: mention pitfalls of e.g. left recursion here, or in the background? Stuff that can't be picked up by a regular linter

A number of modern integrated development environments (\textsc{ide}s) provide code hints to warn programmers about problems in their source code, highlighting offending snippets and suggesting actions to improve suboptimal or incorrect code~\cite{kurbatova_intellij_2021}.
Many of these code analysis tools are designed to detect general issues for the host language, rather than specifically for libraries.
However, tools may also utilise domain-specific code analyses in order to detect issues specific to a particular system or problem domain~\cite{renggli_domain-specific_2010,gregor_stllint_2006}.

\section{Project Goals}
This project aims to explore the potential of harnessing static code analysis techniques to develop a new tool, \texttt{parsley-garnish}, that offers code hints aimed at assisting programmers in writing idiomatic and correct \texttt{parsley} code.
Additionally, for certain issues that can be automatically fixed, \texttt{parsley-garnish} will provide automated actions to resolve the issue. % TODO: via code transformations - put this in the background?
The goal of \texttt{parsley-garnish} is to be used as a companion library to \texttt{parsley}, in order to improve its ease of adoption and to help users enforce best practices.

\TODO{Place this in the right bit (I think intro is good)}
As noted by \textcite{gibbons_dsls_2014}, a deep-embedded \textsc{dsl} consists of two components:
\begin{itemize}
  \item A representation of the language's abstract syntax, in the form of the aforementioned datatype.
  \item Some traversals over the datatype, which gives \emph{semantics} to that syntax.
\end{itemize}
A deep-embedded \textsc{dsl} and a linter for that \textsc{dsl} can share the same abstract syntax, but differ in the semantic interpretation of that syntax:
% TODO: I'm not really getting my point across...
\begin{itemize}
  \item The \textsc{dsl} semantics are evaluation. In this case, \texttt{parsley} interprets its syntax to output a parser.
  \item The linter's semantics are pretty-printing. In this case, \texttt{parsley-garnish} interprets the syntax to output a human-readable representation of the parser.
\end{itemize}
% semantics for parsley: evaluate parser
% semantics for parsley-garnish: pretty-print the parser

\end{document}
