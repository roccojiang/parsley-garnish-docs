\documentclass[../../main.tex]{subfiles}

\begin{document}

\section{Parser Representation}\label{sec:parser-representation}
\TODO{
  This is an INTERMEDIATE SYMBOLIC REPRESENTATION (?)
  more specialised than general-purpose scala ast
  This section is about simplifying in our semantic domain (parsers)

Scalafix runs at the meta-level, outside of the phase distinction of compile- and run-time.
Staged metaprogramming applies optimisations at compile-time, whereas these ``optimisations'' at applied post-compilation
}

% TODO: come back to this after the section body is finished
% Several of the more complex lint rules, most notably \cref{sec:factor-leftrec}, require manipulating parser combinators in a high-level manner.

For example, given two \textsc{ast} nodes \scala{Term.Name("p")} and \scala{Term.Name("q")} corresponding to named parsers \scala{p} and \scala{q}, suppose a transformation involves combining them with the \emph{ap} combinator \scala{<*>}.
One may consider using quasiquotes to achieve this: \scala{q"p <*> q"} would automatically expand to \scala{Term.ApplyInfix(Term.Name("p"), Term.Name("<*>"), Type.ArgClause(Nil), Term.ArgClause(List(Term.Name("q")), None))}.
However, this loses the static inspectability of the individual parsers \scala{p} and \scala{q} -- although quasiquotes can be used as extractor patterns to recover the original \textsc{ast} nodes, their usage as such is discouraged as they can easily result in unintended match errors. % TODO: cite? footnote? https://scalameta.org/docs/trees/guide.html#with-quasiquotes-1
The recommended approach is to pattern match on the \textsc{ast} nodes directly, which is obviously unergonomic even for this small example: to extract the \textsc{rhs} term \scala{q}, one would have to perform a nested pattern match on the \scala{Term.ApplyInfix} term and its \scala{Term.ArgClause} node representing the arguments of the infix function application.

It is hopefully obvious that this would a very painful process for the rule author.
It would be desirable to abstract away from the low-level syntactic \textsc{ast} representation, and instead treat these \textsc{ast} nodes as what they semantically represent -- parsers.

Instead, \cref{fig:parser-adt} shows how parser terms can be represented as an algebraic data type \textsc{adt}, in the same way \scala{parsley} itself uses a deep embedding to represent parsers as pure data objects.
The reasoning behind this approach is the same as that for \textsc{parsley} -- this representation allows parsers to be easily inspected and analysed via pattern matching on constructors.

\begin{figure}[htbp]
\begin{minted}{scala}
trait Parser
case class NonTerminal(ref: Symbol) extends Parser
case class Pure(f: Function) extends Parser
case object Empty extends Parser
case class Choice(p: Parser, q: Parser) extends Parser
case class Ap(p: Parser, q: Parser) extends Parser
...
\end{minted}
\caption{A subset of the core combinators in the \scala{Parser} \textsc{adt}.}
\label{fig:parser-adt}
\end{figure}

% Instead, represent parsers as an algebraic data type \textsc{adt} in the same way that Parsley itself uses a deep embedding to represent combinators as objects.
% Methods on these objects can then be used to manipulate them, and the resulting object can still be pattern matched, maintaining the static inspectability of the parsers.
% So then it's just like writing parsers in Parsley itself: \scala{p <*> q} constructs a \scala{Ap(p, q)} node which can still be pattern matched on.
% And similar to Parsley, representing everything as objects makes it easy to optimise using pattern matching on constructors.
% This representation also then gives us for free the implementation for lint rules such as \emph{Simplify Complex Parsers} rule, which applies parser laws to simplify parsers.

This \namecref{sec:parser-representation} explores the motivation behind this and the design choices made in the implementation.
Use the left-recursion factoring~(\cref{sec:factor-leftrec}) rule as a basis/context to demonstrate the utility of this representation.

% TODO: fix the above "intro" ------------------------------------------------------------------------------

Consider the following left-recursive parser:
\begin{minted}{scala}
lazy val expr: Parsley[String] = (expr, string("a")).zipped(_ + _) | string("b")
\end{minted}
The transformations necessary to remove left recursion from this parser~(\cref{sec:factor-leftrec}), will serve as a running example to motivate the requirements for the parser representation.

\subsection{Detecting Named Parsers}
Before any analysis on parsers can be performed, it is first necessary to identify which \textsc{ast} nodes correspond to parsers.
\texttt{parsley-garnish} builds a map of all parsers defined within a source file, indexed by the unique symbol of its name.

Identifying these \textsc{ast} nodes of interest involves pattern matching on \scala{val}, \scala{var}, and \scala{def} definitions with a type inferred to be some \scala{Parsley[_]} -- this information is accessed by querying the Scalafix semantic \textsc{api} for the node's symbol information.
% In this example, the type of \scala{expr} is explicitly given as the Scala compiler requires this due to being a recursive definition.
Consider the labelled \scala{ast} structure of the \scala{expr} parser:
\begin{minted}{scala}
Defn.Val(
  mods = List(Mod.Lazy()),
  pats = List(Pat.Var(Term.Name("expr"))),
  decltpe = Some(
    Type.Apply(Type.Name("Parsley"), Type.ArgClause(List(Type.Name("String"))))
  ),
  rhs = Term.ApplyInfix(...)
)
\end{minted}
%
The qualified symbol \scala{expr} is used as the key in the map, and the \scala{rhs} term is lifted the intermediate parser representation for analysis.
A reference to the original \textsc{ast} node is also kept so any lint diagnostics or code rewrites can be applied to the correct location in the source file.
Thus, a full traversal through the source file builds a map of all named parsers, representing all non-terminals in the grammar defined within that file.

\subsection{Converting Scalameta Terms to the Parser \textsc{adt}}
Having identified the \textsc{ast} nodes which represent parsers, they need to be transformed into the appropriate \scala{Parser} representation.
This involves pattern matching on the \scala{Term} to determine which parser combinator it represents, and then constructing the appropriate \scala{Parser} instance.

Each \scala{Parser} defines a partial function, \scala{fromTerm}, which creates an instance of that parser from the appropriate \scala{scala.meta.Term}.
These \scala{fromTerm} methods are combined to define a \scala{toParser} extension method on \scala{scala.meta.Term} -- this is where \textsc{ast} nodes are lifted to their corresponding \scala{Parser} representation.
% Use Scalafix's \scala{SymbolMatcher} to match tree nodes that resolve to a specific set of symbols.
% This makes use of semantic information from SemanticDB, so we are sure that a \scala{<*>} is actually within the \scala{parsley.Parsley} package, rather than some other function with the same name.
% This is much more robust compared to HLint, which suffers from false positives due to its reliance on syntactic information only.

The top-level combinator that makes up \scala{expr}'s definition is the choice combinator, \scala{|}.
Scalameta represents this infix application of the \scala{|} operator as so:
\begin{minted}{scala}
Term.ApplyInfix(
  lhs = Term.Apply(...), // AST node for (expr, string("a")).zipped(_ + _)
  op = Term.Name("|"),
  targClause = Type.ArgClause(List()),
  argClause = Term.ArgClause(
    List(
      Term.Apply(
        Term.Name("string"),
        Term.ArgClause(List(Lit.String("b")), None)
      )
    ),
    None
  )
)
\end{minted}
%
This structure therefore guides the implementation of the pattern match in \scala{Choice.fromTerm}:
\begin{minted}{scala}
object Choice {
  val matcher = SymbolMatcher.normalized("parsley.Parsley.`|`", "parsley.Parsley.`<|>`")

  def fromTerm(implicit doc: SemanticDocument): PartialFunction[Term, Choice] = {
    case Term.ApplyInfix(p, matcher(_), _, Term.ArgClause(List(q), _)) =>
      Choice(p.toParser, q.toParser)
  }
}
\end{minted}
%
The definition of this method is fairly self-explanatory: it matches on a \scala{ApplyInfix} term where the operator is the \scala{|} combinator, and recursively applies \scala{toParser} to its \textsc{lhs} and \textsc{rhs} nodes.
Finishing off, the \scala{expr} parser is therefore converted to the following \scala{Parser} instance:
% Choice(
%   Zipped(Function(_ + _), List(NonTerminal(expr), Str(a))),
%   Str(b)
% )
\begin{minted}[escapeinside=\%\%]{scala}
Choice(
  Zipped(%\textcolor{gray}{Function(\_ + \_)}%, List(NonTerminal(expr), Str(a))),
  Str(b)
)
\end{minted}
The exact representation of the \scala{Function} is not important at this momenet -- this is covered in the next \namecref{sec:function-representation}.
For brevity, the remaining code snippets in this \namecref{sec:parser-representation} will simplify the function representations and continue to grey them out.

\subsection{Building New Parsers From Existing Parsers}
Now that raw \textsc{ast} terms can be lifted to the higher-level parser representation, it is easy to build new parsers from existing parsers.
This is crucial for left-recursion factoring, which ``unfolds'' parsers into separate parsers representing the left-recursive and non-left-recursive parts.
These are then recombined to form parsers which are free from left recursion.

Smart constructors are used to make manipulating parser terms resemble writing \scala{parsley} code itself.
These are defined as infix operators, which are written as extension methods on the \scala{Parser} trait:
\begin{minted}{scala}
implicit class ParserOps(private val p: Parser) extends AnyVal {
  def <*>(q: Parser): Parser = Ap(p, q)
  def <|>(q: Parser): Parser = Choice(p, q)
  def map(f: Function): Parser = FMap(p, f)
}
\end{minted}
%
Parser terms can now be manipulated in a manner that looks almost indistinguishable from writing \scala{parsley} code.
For example, the \scala{unfold} method on the \scala{Ap} parser contains this snippet, where \scala{pl}, \scala{ql}, and \scala{q} are parsers (\scala{pe} is not a parser, but rather an \scala{Option} value):
% val lefts = {
%   val llr = pl.map(flip) <*> q
%   val rlr = pe.map(f => ql.map(composeH(f))).getOrElse(Empty)
%   llr <|> rlr
% }
\begin{minted}[escapeinside=\%\%]{scala}
val lefts = {
  val llr = pl.map(%\textcolor{gray}{flip}%) <*> q
  val rlr = pe.map(f => ql.map(%\textcolor{gray}{composeH(f)}%)).getOrElse(Empty)
  llr <|> rlr
}
\end{minted}
Other than the capitalised \scala{Empty} constructor, this would be perfectly valid \scala{parsley} code.

\subsection{Simplifying Parsers Using Parser Laws}\label{sec:simplify-parsers}
After left-recursion factoring is complete, the recombined parsers from the unfolding process are very noisy and difficult to read.
Consider the resulting parser from factoring out the left-recursion in \scala{expr}:
% lazy val expr: Parsley[String] = chain.postfix(
%   empty | (empty.map(a => b => a + b) | empty <*> expr) <*> string("a")
%     | string("b") | empty
% )(
%   (empty.map(FLIP) <*> expr | pure(ID).map(COMPOSE(a => b => a + b)))
%     .map(FLIP) <*> string("a")
%     | empty | empty
% )
\begin{minted}[escapeinside=\%\%]{scala}
lazy val expr: Parsley[String] = chain.postfix(
  empty | (empty.map(%\textcolor{gray}{a => b => a + b}%) | empty <*> expr) <*> string("a")
    | string("b") | empty
)(
  (empty.map(%\textcolor{gray}{Flip}%) <*> expr | pure(%\textcolor{gray}{Identity}%).map(%\textcolor{gray}{Compose(a => b => a + b)}%))
    .map(%\textcolor{gray}{Flip}%) <*> string("a")
    | empty | empty
)
\end{minted}
%
This is obviously unacceptable and completely obfuscates the intent of the parser.
For human readability of the transformed output, it is therefore important to simplify the parser as much as possible.
Now that the parsers are represented as objects, it is easy to pattern match on their constructors.
This improved static inspectability allows us to perform simplifications using the laws that govern parser combinators -- these often form a natural simplification in one direction.
This is similar to the high-level optimisations performed in the Parsley backend as described by \textcite{willis_staged_2023}, using the same parser laws.

\Cref{fig:parser-laws} shows the subset of parser laws utilised by \texttt{parsley-garnish} for parser simplification.
Most of the laws in \cref{fig:parser-laws} have already been shown to hold for Parsley in~\cite{willis_garnishing_2018}; an additional proof for \cref{eqn:alt-fmap-absorb} can be found in \cref{appendix:parser-law-proofs}.

\begin{figure}[htbp]
\centering
\begin{gather}
  % Functor
  \text{\scala{p.map(f).map(g) = p.map(g compose f)}} \label{eqn:functor-comp} \\
  % Applicative functor
  \text{\scala{pure(f) <*> pure(x) = pure(f(x))}} \label{eqn:app-homomorphism} \\
  \text{\scala{pure(f) <*> x = x.map(f)}} \label{eqn:app-fmap} \\
  % Alternative applicative functor
  \text{\scala{empty | u = u}} \label{eqn:alt-left-neutral} \\
  \text{\scala{u | empty = u}} \label{eqn:alt-right-neutral} \\
  \text{\scala{pure(x) | u = pure(x)}} \label{eqn:alt-left-biased-choice} \\
  \text{\scala{empty <*> u = empty}} \label{eqn:alt-empty-absorb} \\
  \text{\scala{empty.map(f) = empty}} \label{eqn:alt-fmap-absorb}
\end{gather}
% I've wanted more fine-grained control, so instead of using cleveref I've manually written out the references -- TAKE CARE to keep them in the same order as the equations
% \caption{Functor~\cref{eqn:functor-comp}, Applicative~\cref{eqn:app-homomorphism,eqn:app-fmap}, and Alternative~\cref{eqn:alt-left-neutral,eqn:alt-right-neutral,eqn:alt-left-biased-choice,eqn:alt-empty-absorb,eqn:alt-fmap-absorb} laws.}
\caption{Functor~(\ref{eqn:functor-comp}), Applicative~(\ref{eqn:app-homomorphism}, \ref{eqn:app-fmap}), and Alternative~(\ref{eqn:alt-left-neutral}--\ref{eqn:alt-fmap-absorb}) laws.}
\label{fig:parser-laws}
\end{figure}

% TODO: vertical spacing here is a bit unsightly, maybe add a \paragraph for these "running example" bits?
In the previous example, it is evident that the most noise results from the \scala{empty} combinators.
These can be eliminated using \cref{eqn:alt-left-neutral,eqn:alt-right-neutral,eqn:alt-empty-absorb,eqn:alt-fmap-absorb}:
\begin{minted}{scala}
lazy val expr: Parsley[String] = chain.postfix(string("b"))(
  (pure(ID).map(COMPOSE(a => b => a + b))).map(FLIP) <*> string("a")
)
\end{minted}
%
The complicated term in the postfix operator can then be simplified as follows:
\begin{minted}[baselinestretch=1.5,escapeinside=\%\%]{scala}
    (pure(ID).map(COMPOSE(a => b => a + b))).map(FLIP) <*> string("a")
% \proofstep{\cref{eqn:app-homomorphism,eqn:app-fmap}} %
    pure(COMPOSE(a => b => a + b)(ID)).map(FLIP) <*> string("a")
% \proofstep{\cref{eqn:app-homomorphism,eqn:app-fmap}} %
    pure(FLIP(COMPOSE(a => b => a + b)(ID))) <*> string("a")
% \proofstep{\cref{eqn:app-fmap}} %
    string("a").map(FLIP(COMPOSE(a => b => a + b)(ID)))
\end{minted}
%
This results in the most simplified form of the parser:
\begin{minted}{scala}
val f: Function = FLIP(COMPOSE(a => b => a + b)(ID))
lazy val expr: Parsley[String] = chain.postfix(string("b"))(string("a").map(f))
\end{minted}

\subsubsection{Implementation}
These simplifications are applied akin to peephole optimisations in a bottom-up traversal of the recursive \scala{Parser} \textsc{adt}.
There are many instances of Parsers, so this leads to a lot of boilerplate code recursing through each case, which is prone to error when we implement it.
To avoid this, we decouple the application of a generic transformation function from the recursive traversal through the datatype.
This is still a hand-written traversal, but heavily inspired by the generic traversal patterns in~\cite{mitchell_uniform_2007}.
Bottom-up transformation takes a partial function, applying the transformation at nodes where it is defined.
The resulting \scala{transform} method on parsers resembles the following (only a few cases shown for brevity):
\begin{minted}{scala}
def transform(pf: PartialFunction[Parser, Parser]): Parser = {
  val p = this match {
    case Ap(p, q)      => Ap(p.transform(pf), q.transform(pf))
    case Zipped(f, ps) => Zipped(f, ps.map(_.transform(pf)))
    case Pure(f)       => Pure(f)
    ...
  }
  if (pf.isDefinedAt(p)) pf(p) else p
}
\end{minted}
%
There is also a need for a \scala{rewrite} method to apply a transformation exhaustively until a normal form is reached.
This is implemented in terms of \scala{transform}, applying the partial function everywhere and re-applying it until it no longer makes a change.
\begin{minted}{scala}
def rewrite(pf: PartialFunction[Parser, Parser]): Parser = {
  def pf0(p: Parser) = if (pf.isDefinedAt(p)) pf(p).rewrite(pf) else p
  this.transform(pf0)
}
\end{minted}
%
Therefore, any transformation on parsers can be defined without having to worry about any recursive traversal boilerplate.
Using \scala{rewrite}, parser simplification can then be expressed in a clean and maintainable manner:
\begin{minted}{scala}
def simplify: Parser = this.rewrite {
  // p.map(f).map(g) == p.map(g compose f)
  case FMap(FMap(p, f), g) => FMap(p, composeH(g, f))
  // u <|> empty == u
  case Choice(u, Empty) => u
  // pure(f) <|> u == pure(f)
  case Choice(Pure(f), _) => Pure(f)
  ...
}
\end{minted}
%
Additionally, the \scala{Parser} trait is sealed, so there will be compiler warnings if a new case is added and the \scala{transform} method is not updated.
Overall, this approach still requires a hand-written traversal so it is more error-prone than a generic derivation.
However, that would require usage of an external library such as \texttt{shapeless}\footnote{\url{https://github.com/milessabin/shapeless}},
which is not desired as the complexity of the \textsc{adt} is not high enough to warrant bringing in an extra dependency just for this purpose.

\subsection{Converting Parsers Back to Scalameta Terms}
After the transformations on parsers are complete, they need to be converted back to a textual representation to be applied as a Scalafix patch.
It is actually rather trivial to do so, by borrowing the pretty-printing capabilities of Scalameta terms.
This transformation is thus the inverse of the \scala{fromTerm} transformation.
This can be written using Scalameta quasiquotes to construct the \scala{Term} nodes.
The \scala{Parser} trait defines this transformation as the method \scala{term}, for example:
\begin{minted}{scala}
case class Zipped(func: Function, parsers: List[Parser]) extends Parser {
  val term: Term = q"(..${parsers.map(_.term)}).zipped(${func.term})"
}
\end{minted}

\end{document}
