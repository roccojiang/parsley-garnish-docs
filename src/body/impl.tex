\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Simplifying Parsers and Expressions}\label{sec:impl}
At this stage, the left-recursion factoring transformation leaves a lot to be desired in terms of output quality.
This \namecref{sec:impl} takes a step back from linting rules and focuses on ensuring how transformed terms can get pretty-printed in a human-readable form.
The following ideas are explored:
\begin{itemize}
  \item First, \cref{sec:simplify-parsers} discusses how parser terms can be simplified via domain-specific optimisations based on parser laws.
  \item Afterwards, \cref{sec:function-representation} discusses how expressions can be partially evaluated, to some extent. This is achieved using another intermediate \textsc{ast}, this time based on the $\lambda$-calculus, which unlocks the idea of $\beta$-reduction and normalisation as tools to reduce the complexity of these terms.
\end{itemize}

% TODO
% Writing domain-specific lint rules unlocks the potential for more powerful and interesting transformations utilising specialised domain knowledge.
% Desirable:
% * inspectability for analysis (that's what we're here for!) and optimisation
% The purpose of this chapter is to describe the intermediate representations of parsers (\cref{sec:parser-representation}) and functions (\cref{sec:function-representation}).
% Show that terms must be simplified to a normal form
% Demonstrate equivalence to dsl optimisations in staged metaprogramming
% Scalafix runs at the meta-level, outside of the phase distinction of compile- and run-time.
% Staged metaprogramming applies optimisations at compile-time, whereas these ``optimisations'' at applied post-compilation

\subfile{impl/parser}
\subfile{impl/expr}

\end{document}
