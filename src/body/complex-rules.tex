\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Using the New Parser \textsc{ast}}
The ability to simplify parsers, as well as normalising their expression arguments, makes it feasible to use the intermediate \scala{Parser} \textsc{ast} for high-level parser transformations.

\section{Removing Left-Recursion: Revisited}
\Cref{sec:factor-leftrec} left off with a disappointing result for the left-recursion factorisation transformation, producing a mostly unreadable output in \cref{fig:leftrec-example-bad}.
This transformation can now be revisited given the improvements made to the \scala{Parser} \textsc{ast}.
The following changes can be made to improve the rule's output:
\begin{itemize}
  \item Parser terms should be simplified via parser laws to get a more readable final output.
  \item Parsers should take advantage of the new \scala{Expr} representation to allow for partial evaluation of higher-order functions, rather than manipulating terms as opaque quasiquotes.
  \item The higher-order functions \scala{flip} and \scala{compose} can now be represented as \scala{Expr} lambda expressions, eliminating the need to patch in their definitions as previously required in \cref{sec:leftrec-utils}.
\end{itemize}

Define normalise and prettify, attempt to resugar decomposed parsers back into a nicer form.

\begin{minted}{scala}
trait Parser {
  def normalise: Parser = this.simplify.normaliseExprs
  def isEquivalent(other: Parser) = this.normalise == other.normalise

  def prettify: Parser = this.normalise.resugar
  def resugar: Parser = this.rewrite {
    // p.map(\x -> \y -> y) <*> q == p ~> q
    case FMap(p, Abs(_, Abs(Var(y, _), Var(z, _)))) <*> q if (y == z) => p ~> q
    // p.map(\x -> \y -> x) <*> q == p <~ q
    case FMap(p, Abs(Var(x, _), Abs(_, Var(z, _)))) <*> q if (x == z) => p <~ q

    // f.curried.map(p) <*> q == (p, q).zipped(f)
    case FMap(p1, Abs(x1, Abs(x2, body))) <*> p2 =>
      Zipped(AbsN(List(x1, x2), body), List(p1, p2))

  }.transform {
    // Scala 2 cannot resolve implicit stringLifts in some positions
    case FMap(Str(s, _), f) => FMap(Str(s, implicitSyntax = false), f)
    case Zipped(f, Str(s, _) :: ps) => Zipped(f, Str(s, implicitSyntax = false) :: ps)
  }
}
\end{minted}

No .curried
\begin{minted}{scala}
trait Expr {
  def curried: Expr = this match {
    case Abs(x, f)        => Abs(x, f.curried)
    case AbsN(x :: xs, f) => Abs(x, AbsN(xs, f).curried)
    case _                => this
  }
}
\end{minted}

\begin{minted}{scala}
trait LiftLike extends Parser {
  def unfold() = {
    val curriedFunc = Pure(func match {
      // If the Expr is still opaque, it is treated as before
      case Translucent(term, env) => Translucent(q"($term).curried", env)
      // If statically inspectable, curry the lambda expr properly
      case _ => func.curried
    })

    parsers.foldLeft(curriedFunc)(_ <*> _).unfold
  }
}
\end{minted}

% * Parsers should be simplified before making the patch
% * Update to use \scala{Expr} rather than quasiquotes, to allow the application of higher-order functions to be partially evaluated
% * Therefore no need to patch in definitions for flip and compose, since they are now lambdas
* no .curried
* Resugaring
* Optimisation: normalise leftrec part to see if it comes to empty -- if so, don't inline in the NT case

\begin{minted}{scala}
def transform(results: Option[Expr], nonLeftRec: Parser, leftRec: Parser) = {
  val result = results match {
    case None    => Empty
    case Some(t) => Pure(t)
  }

  leftRec.normalise match {
    case Empty   => Patch.empty // not left-recursive, don't rewrite
    case Pure(_) => Patch.lint(LeftRecDerivesEmptyLint) // left-recursive but unfixable
    case _ =>
      val transformed = Postfix(nonLeftRec | results, leftRec).prettify
      Patch.replaceTree(originalTree, transformed.toString)
  }
}
\end{minted}


% TODO: significant engineering work to make sure things compile

\subsection*{The Final Result}
\begin{minted}{scala}
lazy val example: Parsley[String] =
  chain.postfix[String](string("b"))(string("a").map(x1 => x2 => x2 + x1))
\end{minted}

\section{Simplify Parser}
The improved \scala{Parser} \textsc{ast} also gives a new auto-fix rule for free: automatic simplification of parsers.

Idea
* For each parser, simplify it via parser laws, and compare to its original.
* If the result is different, apply the simplified version as a patch.

The implementation of the entire rule is only 20 lines long:
\begin{minted}{scala}
class SimplifyParser extends SemanticRule("SimplifyParser") {
  override def fix(implicit doc: SemanticDocument): Patch = {
    getAllParserDefns.map { case ParserDefinition(_, parser, _, originalTree) =>
      val simplifiedParser = parser.prettify
      if (parser.normaliseExprs != simplifiedParser) {
        val simplifiedParserTerm = simplifiedParser.term.syntax
        Patch.replaceTree(originalTree, simplifiedParserTerm)
      } else {
        Patch.empty
      }
    }.asPatch
  }
}
\end{minted}
%
% Subtle detail:
% * During expression normalisation, bound variables may be $\alpha$-renamed
% * So a parser that hasn't actually changed may still be different when compared to the original
% * So expressions within the original are also normalised -- $\alpha$-equivalence is preserved between normalised expressions
% * Then this doesn't result in changing weird things like variable names

* Apply parser laws, re-using Parser and Func representations to do cool things
prettify = resugar . normaliseFunctions . simplify

\section{Avoid Parser Redefinition}
\TODO{
Similar in spirit to the previous rule
* Catch cases when user manually writes out a parser that is already defined in the library

\Cref{sec:parser-rewrites} makes it easy to write syntax-directed rewrite rules on parsers.
Less annoying than working with scalameta ast directly
better design patterns idk, symbolmatcher etc all in one place defined as a trait for parser
% ** although still annoying for e.g. def countMany(p: Parsley[_]): Parsley[Int] = p.foldLeft(0)((n, _) => n + 1)    <---- still no good way to pattern match expr given that "n + 1" is translucent, easier to just reify this back to scala.meta.term and then low-level pattern match

so:
Looking for dumb definitions of things e.g. endBy(p, sep) implemented as many(p <* sep); or count implemented as a foldLeft, fold fusion
}

% \section{Convert to Parser Bridge}
% \TODO{
% * This would be cool, idk if I have time though, but this should also piggyback off of Func
% * the pos bridges don't actually exist, so we can ignore that case and just say its too much code synthesis
% * shouldn't be too bad? idk
% * indicate limitations that this will only work if the ADT is defined in the same file, in order to extend it
% }

\end{document}
