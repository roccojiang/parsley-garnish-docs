\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Evaluation}\label{sec:evaluation}

* Project ended up requiring a lot more work on internal machinery i.e. intermediate ASTs in order to get high-level parser transformations to work
* This is good because it makes it allows parsley-garnish to be easily extended with more domain-specific rules in the future
* But it also meant that the project was more complex than initially anticipated, and that the variety of implemented linting rules were not as comprehensive as I would have liked
* Left-recursion transformation is the big one which motivated much of the work on the intermediate ASTs in the first place, and therefore uses it the most
* Evaluating the outputs of the left-recursion transformation therefore also evaluates the success of the intermediate machinery

\section{Removing Left-Recursion}\label{sec:eval-leftrec}
Broadly speaking, there are three classes of left-recursion: direct, indirect, and hidden left-recursion.
This \namecref{sec:eval-leftrec} evaluates \texttt{parsley-garnish}'s ability to handle each of these cases, based on a mostly qualitative set of evaluation criteria:
\begin{itemize}
  \item Was the instance of left-recursion detected?
  \item If an auto-fix was performed, was it correct?
  \item How clear was the output? How does it compare to an idiomatic, manually fixed version?
  \item Does the output compile?
\end{itemize}
% TODO: given the nature of the transfomration it is expected to be able to handle all cases
%
The following examples assume the existence of a \scala{number} parser, defined the same way as earlier in \cref{sec:background-parsers}:
\begin{minted}{scala}
val number: Parsley[Int] = digit.foldLeft1(0)((n, d) => n * 10 + d.asDigit)
\end{minted}

\subsection{Direct Left-Recursion}
\emph{Direct} left-recursion is the simplest and most obvious form of left-recursion, where a parser directly refers to itself in its definition.
Thus, it is the easiest form of left-recursion to detect and handle, regardless of the transformation technique used.
This section evaluates \texttt{parsley-garnish}'s handling of direct left-recursion in a few different scenarios.

\subsubsection{Unary Postfix Operator}
The following minimal grammar for a postfix unary incrementing operator is directly left-recursive:
% <inc> ::= <inc> '+' | <number>
\begin{align*}
\langle \mathit{inc} \rangle &::= \langle \mathit{inc} \rangle \enspace \text{`\texttt{+}'} \enspace | \enspace \langle \mathit{number} \rangle
\end{align*}
%
A parser for this grammar, written in left-recursive form, would be as follows:
\begin{minted}{scala}
enum Expr {
  case Num(n: Int)
  case Inc(x: Expr)
}
val incs: Parsley[Expr] = Inc.lift(incs) <~ "+" | Num.lift(number)
\end{minted}
%
In this instance, \texttt{parsley-garnish} detects the left-recursion and transforms the parser into the form shown below; this is compared with a hand-written version.
\begin{minted}{scala}
// Transformed by parsley-garnish
val incs = chain.postfix[Expr](number.map(x1 => Num(x1)))
                              (string("+").map(x1 => x2 => Inc(x2)))
// "Optimal" version written by hand
val incsByHand = chain.postfix[Expr](number.map(Num(_)))("+" as Inc)
\end{minted}
%
The output from \texttt{parsley-garnish} manages to compile and is clear and idiomatic, although the hand-written version is slightly more concise.
These two versions can be shown to be equivalent via equational reasoning --
the first argument to \scala{postfix} is obviously the same, but with placeholder syntax instead of using explicit lambda arguments.
The second argument can be derived as follows:
\begin{minted}[baselinestretch=1.5,escapeinside=\%\%]{scala}
string("+").map(x1 => x2 => Inc(x2))
% \proofstep{Definition of \texttt{as}:  \texttt{p.as(x) = p.map(\textunderscore => x)}} %
string("+") as (x2 => Inc(x2))
% \proofstep{$\eta$-reduction on \texttt{Inc}} %
string("+") as Inc
% \proofstep{Re-introduce \emph{Implicit Conversions} pattern} %
"+" as Inc
\end{minted}
%
This example highlights some subtle points that \texttt{parsley-garnish} considers in order to improve the likelihood of producing compilable output:
\begin{itemize}
  \item The type ascription \scala{chain.postfix[Expr]} is not always necessary, although in this case it is actually required to help Scala correctly unify the types expected by the combinator. Since \texttt{parsley-garnish} cannot typecheck its outputs, it always includes this type ascription to boost Scala's type inference.
  \item The original parser used the \emph{Implicit Conversions} pattern to elide the \scala{string} combinator, but \texttt{parsley-garnish} re-introduces the explicit \scala{string} combinator in its output. This is intentional -- Scala 2 has trouble with implicit conversions in certain positions, such as in this case where \scala{"+".map(...)} would not compile. \texttt{parsley-garnish} attempts to add the explicit combinator back in cases like this, although in general it will respect the original style the parser was written in.
\end{itemize}

\subsubsection{Arithmetic Expression Language}
As a larger-scale example, the left-associative arithmetic operators from \cref{sec:background-parsers} are also defined in a directly left-recursive manner.
Recall how the hand-written version using \scala{chain.left1} was presented:
\begin{minted}{scala}
lazy val expr: Parsley[Expr] = chain.left1(term)('+' as Add(_, _) | '-' as Sub(_, _))
\end{minted}
%
Compared with the full transformed output from \texttt{parsley-garnish}:
\begin{minted}{scala}
lazy val expr = chain.postfix[Expr](term)(
  ('+' ~> term).map(x1 => x2 => Add(x2, x1)) | ('-' ~> term).map(x1 => x2 => Sub(x2, x1)))
lazy val term = chain.postfix[Expr](atom)(
  ('*' ~> atom).map(x1 => x2 => Mul(x2, x1)) | ('/' ~> atom).map(x1 => x2 => Div(x2, x1)))
lazy val atom = '(' ~> expr <~ ')' | number.map(Num(_))
\end{minted}
%
This also manages to successfully compile, and is relatively clear to read.
However, it does highlight a current shortcoming of the left-recursion rule: left-recursive parsers can only be transformed into the most generalised \scala{postfix} form, which may not always be the most optimal choice of combinator.
In this case, the \scala{chain.left1} combinator would've been a more appropriate choice; even better would be the \scala{precedence} combinator, since the grammar forms multiple layers of expression operators.

It is theoretically possible to automatically transform a \scala{postfix} parser into one of its more specialised brethren, but this would require a more sophisticated ability to factor out common patterns in parsers and expressions.
% This comes at odds with the current machinery, which focuses on simplification and normalisation, and may lose the high-level patterns that would be helpful for factoring out common sub-expressions.
\textcite{willis_parsley_2024} demonstrates how \scala{chain.left1} can be defined in terms of \scala{postfix}, presented in Haskell as it illustrates the relationship more clearly.
The only major syntactical difference of note is that Haskell uses \haskell{<$>} for the \scala{map} combinator:
\begin{equation*}
\text{\haskell{chainl1 p op}} \enspace = \enspace \text{\haskell{postfix p (flip <$> op <*> p)}}
\end{equation*}
%
Using this definition, the \scala{postfix} version can be provably shown to be equivalent to the \scala{chain.left1} version.
This proof will again use Haskell syntax as it is more suitable for equational reasoning.
The goal is to show that \scala{('+' ~> term).map(x1 => x2 => Add(x2, x1))} can be rewritten in the form \scala{op.map(flip) <*> p}, where \scala{p} is \scala{term} and \scala{op} is shown to be \scala{'+' as Add(_, _)}.
\begin{lstlisting}
    (\x1 x2 -> Add x2 x1) <$> ('+' *> term)
% \proofstep{Definition of \texttt{flip}} %
    flip Add <$> ('+' *> term)
% \proofstep{Definition of \texttt{*>}  (equivalent to \texttt{\~{}>} in Scala):  \texttt{p *> q = const id <\$> p <*> q}} %
    flip Add <$> (const id <$> '+' <*> term)
% \proofstep{Re-association:  \texttt{u <*> (v <*> w) = pure ($\circ$) <*> u <*> v <*> w}} %
    pure (%$\circ$%) <*> flip Add <$> (const id <$> '+') <*> term
% \proofstep{Applicative fusion:  \texttt{pure f <*> pure x = pure (f x)}} %
    (flip Add .) <$> (const id <$> '+') <*> term
% \proofstep{Functor composition: \texttt{fmap f $\circ$ fmap g = fmap (f $\circ$ g)}} %
    ((flip Add .) . const id) <$> '+' <*> term
% \proofstep{Point-free manipulation} %
    (flip . const Add) <$> '+' <*> term
% \proofstep{Functor composition, in reverse} %
    flip <$> (const Add <$> '+') <*> term
% \proofstep{Definition of \texttt{\$>}  (equivalent to \texttt{.as} in Scala)} %
    flip <$> ('+' $> Add) <*> term
\end{lstlisting}
%
The same proof can be applied to the other operators, and the \scala{map} combinator distributes over choice:
\begin{equation*}
\text{\scala{(u | v).map(f)}} \enspace = \enspace \text{\scala{u.map(f) | v.map(f)}}
\end{equation*}
%
Therefore, the proof shows that the final term obtained from \texttt{parsley-garnish} can be rewritten in the form \scala{op.map(flip) <*> p}, so the obtained \scala{postfix} parser is equivalent to the hand-written version using \scala{chain.left1}.

\subsubsection{Evaluating the Arithmetic Expression Language}
The evaluating parser variant of the same grammar, as presented in the introduction, has the same resulting form:
\begin{minted}{scala}
lazy val expr: Parsley[Float] = chain.postfix[Float](term)(
  ('+' ~> term).map(x1 => x2 => x2 + x1) | ('-' ~> term).map(x1 => x2 => x2 - x1))
\end{minted}
%
However, in this case, the output unfortunately fails to compile.
Scala's local type inference prevents the compiler from inferring the types of the \scala{x2} parameters, as the arithmetic operators used in the lambdas are overloaded.
This problem does not occur for the previous example, since the \scala{Expr} constructors are explicitly and unambiguously typed.
Users will have to manually fix \texttt{parsley-garnish}'s output by adding an explicit type annotation \scala{(x2: Float)}.

Resolving this issue is future work: the most likely solution is to refactor the parser so that they do not take curried functions, which would make it easier for Scala to infer their types.
For example, if the parser was refactored into the \scala{chain.left1} form utilising the \scala{as} combinator, the addition function \scala{_ + _} would be in a fully uncurried form.

\paragraph{Summary}
Direct left-recursion is the most straightforward form of left-recursion to detect, so it is unsurprising that \texttt{parsley-garnish} handles it well.
The transformation on these test examples are provably correct, and the resulting parsers are relatively clear and idiomatic.
\texttt{parsley-garnish} also takes care to improve the likelihood of producing compilable output, although there is still some future work to be done in this area.
The most significant weakness is the inability to specialise the \scala{postfix} parser into a more specific form, however this is not a critical issue as the \scala{postfix} form is still correct and idiomatic.

\subsection{Indirect Left-Recursion}
Instances of \emph{indirect} left-recursion are harder to detect, since the parser's reference to itself takes more than one step to reach.
Consider the following alternative grammar for arithmetic expressions, reduced to only addition for simplicity:
% <expr> ::= <add> | '(' <expr> ')' | <number>
% <add> ::= <expr> '+' <expr>
\begin{align*}
\langle \mathit{expr} \rangle &::= \langle \mathit{add} \rangle \enspace | \enspace \text{`\texttt{(}'} \; \langle \mathit{expr} \rangle \; \text{`\texttt{)}'} \enspace | \enspace \langle \mathit{number} \rangle \\
\langle \mathit{add} \rangle &::= \langle \mathit{expr} \rangle \enspace \text{`\texttt{+}'} \enspace \langle \mathit{expr} \rangle 
\end{align*}
%
The indirect left-recursive cycle arises since \scala{expr} firstly needs to parse \scala{add}, which firstly needs to parse \scala{expr}, and so on.
This grammar can be naïvely translated in its left-recursive form in the following code segment.
For variety, this example utilises the \emph{Parser Bridges} pattern instead of using \scala{lift} combinators:
\begin{minted}{scala}
enum Expr {
  case Num(n: Int)
  object Num extends ParserBridge1[Int, Num]
  case Add(x: Expr, y: Expr)
  object Add extends ParserBridge2[Expr, Expr, Add]
}
lazy val expr: Parsley[Expr] = add | '(' ~> expr <~ ')' | Num(number)
lazy val add: Parsley[Expr] = Add(expr, '+' ~> expr)
\end{minted}
%
\texttt{parsley-garnish} successfully detects the indirect left-recursion and offers an automated fix.
For brevity, the parser type annotations will be omitted in subsequent examples, as they are not changed by \texttt{parsley-garnish}.
\begin{minted}{scala}
lazy val expr = chain.postfix[Expr]('(' ~> expr <~ ')' | number.map(x1 => Num(x1)))
                                   (('+' ~> expr).map(x1 => x2 => Add(x2, x1)))
lazy val add = Add(expr, '+' ~> expr) // unchanged and no longer referenced by expr
\end{minted}
%

* can handle it
* but it's a bit more cluttered, since it has to remove left-recursion on two levels, inlining the add parser into the expr parser
* also, fails to resugar the parser bridge in number.map(x1 => Num(x1))

Hidden left-recursion:
\begin{align*}
\langle \mathit{a} \rangle &::= \langle \mathit{b} \rangle \; \langle \mathit{a} \rangle \; \dotsb \\
\langle \mathit{b} \rangle &::= \epsilon
\end{align*}

\begin{minted}{scala}
lazy val a: Parsley[Int] = b ~> a
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// error: [FactorLeftRecursion] Left-recursion detected, but could not be removed from a.
// The resulting chain would be given a parser which consumes no input,
// causing it to loop indefinitely:
// chain.postfix[Int](some(digit) ~> a)(pure(x1 => x1))

lazy val b: Parsley[Int] = many(digit).map(_.mkString.toInt)
\end{minted}

% TODO: perform experiment: types of left recursion on the rule - evaluation criteria??
% TODO: library ergonomics - see ethan's thesis
% TODO: benchmarks here?

% A large corpus of student WACC parsers is available to evaluate the real-world applicability of \texttt{parsley-garnish}.
% This can be utilised to assess the tool's ability to achieve quantitative and qualitative metrics.

% The large number of parsers available to test can help evaluate the correctness and accuracy of each lint rule.
% We might find that certain rules are more prone to false positives than others, or that some automated refactorings may introduce new issues such as compilation errors.
% These quantitative metrics can be counted and used to evaluate rules against each other, as well as the overall effectiveness of the tool.

% We can also estimate the proportion of issues that \texttt{parsley-garnish} is able to detect automatically.
% This can be done by comparing the number of issues detected automatically against the number of issues found manually by a code reviewer.

% Qualitative metrics such as the quality of automated fixes can also be assessed by manually reviewing the output of the tool.
% For example, an issue I pointed out in the project plan is that the output of the left-recursion transformation may be in a form that is ``ugly'' when it could be simplified to a much more human-readable form.
% The quality of fixes would affect the practicality of the \texttt{parsley-garnish}, since users may be reluctant to apply automated fixes if the output quality can be poor.

% Furthermore, the performance of \texttt{parsley-garnish} can be evaluated in terms of execution time and resource consumption.
% There are no direct competitors to benchmark against, but we can still evaluate the tool's performance against a baseline of acceptable performance, or perhaps a collection of other Scala static analysis tools deemed to be of similar complexity.
% I am thinking of benchmarking the tool during development as well, since it may affect design decisions such as implementing some rules as purely syntactic rather than semantic rules.
% I am not sure how much resource overhead a semantic rule would incur, so this could be insignificant or a major tradeoff (between speed, correctness, and accuracy) to consider.

% Finally, it is possible to gather feedback from students interested in using \texttt{parsley-garnish} to improve their WACC parsers.
% User surveys and interviews would provide insights into the tool's usability, helpfulness, and areas for improvement.
% Although the timing of the WACC Lab does not align with the project timeline, I am hoping that some students may still be interested in trying out the tool on their final WACC submissions or possibly personal projects using \texttt{parsley}.

\end{document}
