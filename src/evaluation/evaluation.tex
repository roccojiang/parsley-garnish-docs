\documentclass[../../main.tex]{subfiles}

\begin{document}

\ourchapter{Evaluation}\label{sec:evaluation}

* Project ended up requiring a lot more work on internal machinery i.e. intermediate ASTs in order to get high-level parser transformations to work
* This is good because it makes it allows parsley-garnish to be easily extended with more domain-specific rules in the future
* But it also meant that the project was more complex than initially anticipated, and that the variety of implemented linting rules were not as comprehensive as I would have liked
* Left-recursion transformation is the big one which motivated much of the work on the intermediate ASTs in the first place, and therefore uses it the most
* Evaluating the outputs of the left-recursion transformation therefore also evaluates the success of the intermediate machinery
Evaluation criteria:
* Was it able to detect this instance of left-recursion?
* If it performed an auto-fix, correctness
* Clarity of output
* Does it compile?

* Dealing with types of syntactic sugar in parsley

Types of left-recursion:
Assuming we have the number parser from before:
\begin{minted}{scala}
val number: Parsley[Int] = digit.foldLeft1(0)((n, d) => n * 10 + d.asDigit)
\end{minted}

Direct left-recursion
% <inc> ::= <inc> '+' | <number>
\begin{align*}
\langle \mathit{inc} \rangle &::= \langle \mathit{inc} \rangle \enspace \text{`\texttt{+}'} \enspace | \enspace \langle \mathit{number} \rangle
\end{align*}
\begin{minted}{scala}
enum Expr {
  case Num(n: Int)
  case Inc(x: Expr)
}

val incs: Parsley[Expr] = Inc.lift(incs) <~ "+" | Num.lift(number)
\end{minted}
\begin{minted}{scala}
// Transformed by parsley-garnish
val incs = chain.postfix[Expr](number.map(x1 => Num(x1)))
                              (string("+").map(x1 => x2 => Inc(x2)))
// "Optimal" version written by hand
val incsByHand = chain.postfix[Expr](number.map(Num(_)))("+" as Inc)
\end{minted}
Note \scala{chain.postfix[Expr]} type ascription is necessary in this case to help type inference -- even in the hand-written version.
This is not always necessary, but since parsley-garnish cannot typecheck its outputs, it is always included.

Indirect left-recursion
% <expr> ::= <add> | '(' <expr> ')' | <number>
% <add> ::= <expr> '+' <expr>
\begin{align*}
\langle \mathit{expr} \rangle &::= \langle \mathit{add} \rangle \enspace | \enspace \text{`\texttt{(}'} \; \langle \mathit{expr} \rangle \; \text{`\texttt{)}'} \enspace | \enspace \langle \mathit{number} \rangle \\
\langle \mathit{add} \rangle &::= \langle \mathit{expr} \rangle \enspace \text{`\texttt{+}'} \enspace \langle \mathit{expr} \rangle 
\end{align*}
\begin{minted}{scala}
enum Expr {
  case Num(n: Int)
  case Add(x: Expr, y: Expr)
}

lazy val expr: Parsley[Expr] = add | '(' ~> expr <~ ')' | num
lazy val add: Parsley[Expr] = (expr, '+' ~> expr).zipped(Add(_, _))
\end{minted}
For brevity, the type annotations will be omitted in the transformed code, as they are not changed by parsley-garnish.
\begin{minted}{scala}
// Transformed by parsley-garnish
lazy val expr = chain.postfix[Expr]('(' ~> expr <~ ')' | num)
                                   (('+' ~> expr).map(x1 => x2 => Add(x2, x1)))
lazy val add = (expr, '+' ~> expr).zipped(Add(_, _)) // no longer referenced by expr
\end{minted}

Hidden left-recursion:
\begin{align*}
\langle \mathit{a} \rangle &::= \langle \mathit{b} \rangle \; \langle \mathit{a} \rangle \; \dotsb \\
\langle \mathit{b} \rangle &::= \epsilon
\end{align*}

\begin{minted}{scala}
lazy val a: Parsley[Int] = b ~> a
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// error: [FactorLeftRecursion] Left-recursion detected, but could not be removed from a.
// The resulting chain would be given a parser which consumes no input,
// causing it to loop indefinitely:
// chain.postfix[Int](some(digit) ~> a)(pure(x1 => x1))

lazy val b: Parsley[Int] = many(digit).map(_.mkString.toInt)
\end{minted}

% TODO: perform experiment: types of left recursion on the rule - evaluation criteria??
% TODO: library ergonomics - see ethan's thesis
% TODO: benchmarks here?

% A large corpus of student WACC parsers is available to evaluate the real-world applicability of \texttt{parsley-garnish}.
% This can be utilised to assess the tool's ability to achieve quantitative and qualitative metrics.

% The large number of parsers available to test can help evaluate the correctness and accuracy of each lint rule.
% We might find that certain rules are more prone to false positives than others, or that some automated refactorings may introduce new issues such as compilation errors.
% These quantitative metrics can be counted and used to evaluate rules against each other, as well as the overall effectiveness of the tool.

% We can also estimate the proportion of issues that \texttt{parsley-garnish} is able to detect automatically.
% This can be done by comparing the number of issues detected automatically against the number of issues found manually by a code reviewer.

% Qualitative metrics such as the quality of automated fixes can also be assessed by manually reviewing the output of the tool.
% For example, an issue I pointed out in the project plan is that the output of the left-recursion transformation may be in a form that is ``ugly'' when it could be simplified to a much more human-readable form.
% The quality of fixes would affect the practicality of the \texttt{parsley-garnish}, since users may be reluctant to apply automated fixes if the output quality can be poor.

% Furthermore, the performance of \texttt{parsley-garnish} can be evaluated in terms of execution time and resource consumption.
% There are no direct competitors to benchmark against, but we can still evaluate the tool's performance against a baseline of acceptable performance, or perhaps a collection of other Scala static analysis tools deemed to be of similar complexity.
% I am thinking of benchmarking the tool during development as well, since it may affect design decisions such as implementing some rules as purely syntactic rather than semantic rules.
% I am not sure how much resource overhead a semantic rule would incur, so this could be insignificant or a major tradeoff (between speed, correctness, and accuracy) to consider.

% Finally, it is possible to gather feedback from students interested in using \texttt{parsley-garnish} to improve their WACC parsers.
% User surveys and interviews would provide insights into the tool's usability, helpfulness, and areas for improvement.
% Although the timing of the WACC Lab does not align with the project timeline, I am hoping that some students may still be interested in trying out the tool on their final WACC submissions or possibly personal projects using \texttt{parsley}.

\end{document}
